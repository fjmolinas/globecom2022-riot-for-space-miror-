\section{Cubedate Evaluation and Discussion}
\label{sec:evaluation}

The analysis of the implementation was two-fold, first we evaluate how the SUIT
based architecture fitted the CubeSat and CubeSat hosted payload use case.
Second, we discuss possible modifications to the workflow, architecture and
protocols.

\subsection{Evaluation}

In the following, code measurements where generated compiling with ARM GCC 10.2.1,
optimized for code size. The crypto library used is D.Beer C25519 library, this
is the library with the lowest footprint for ED25519 as shown in~\cite{zandberg2019secure}.

\subsubsection{Memory Footprint}

To evaluate the RAM and flash footprint of the CubeDate architecture we evaluate them
in two configurations, furthermore we categorize the different components to
distinguish the SUIT endured overhead

\begin{itemize}
    \item \textbf{ThingSat} refers to the ThingSat payload application with no
    software updates support
    \item \textbf{CubeDate} implementation of the CubeDate architecture on the
    ThingSat payload
    \item CAN (Controller Area Network) stack as well as low level interface
    \item Crypto includes all cryptographic algorithms such as digest algorithm, digital
    signature, ECC and bignum, as well as pseudo-random numbers generator
    \item CoAP protocol library (CoAP endpoint stack excluded)
    \item CSP (Cube Sat Protocol) network stack
    \item LoRa GW includes the sx1302 driver as well as the gateway code
    \item SUIT englobe all components enabling retrieval and installation of suit data
    (fw or other), this include e.g. the CoAP endpoint stack.
    \item Firmware: application specific code related to the CubeSat Payload excluding
    the LoRa gateway
\end{itemize}

The flash memory footprints (total and broken down per component) are shown in
\autoref{tab:footprint}. It can be seen that the overhead of Cubedate for ThingSat
is of \~4Kbytes of RAM and \~19Kbytes of flash.

In \autoref{tab:manifest-overhead} network transfer overhead is measured against the average mission file size (700Bytes) and the average firmware image size (200 KBytes).

\begin{table}[ht]
\begin{adjustbox}{width=0.8\columnwidth,center}
    \centering
    \includestandalone[width=1\columnwidth]{Figures/texfigs/memory_footprint_table}
\end{adjustbox}
\caption{Cubedate implementation: memory footprint in Bytes.}
\label{tab:footprint}
\end{table}

\subsubsection{Standarized Network Stack Usage}

CSP was designed to give CubeSat sub-systems developers the same features as an
TCP/IP stack without the overhead of the IP header, allowing to run on constrained
systems with under 4Kbytes of RAM. Unless running on this kind of very constrained
devices using CSP can be contested. A minimal CoAP server example running on
LibCSP or RIOTs default IPv6/UDP network stack (GNRC) yields similar numbers of RAM/Flash
usage: 10KB\/30KB (CSP) vs 8KB/31KB (GNRC). Optimal compression of an Ipv6 header
can shrink the size from 48bytes to 4Bytes, comparable to CSP2.0 3Bytes header.
Furthermore  6loCAN\cite{wachter20206locan01}, SCHC\cite{rfc8724}, allow to
optimize IPv6 for CAN-BUS or LoRa network. What is gained in simplicity is eventually
lost by using a not standard network stack, i.e. using standard application
layer protocols.

\begin{table}[ht]

\begin{adjustbox}{width=0.5\columnwidth,center}
    \centering
    \includestandalone[width=1\columnwidth]{Figures/texfigs/manifest_overhead_table_simplified}
\end{adjustbox}
\caption{Cubedate implementation: SUIT metadata overhead.}
\label{tab:manifest-overhead}
\end{table}

\subsubsection{SUIT Authentication}

SUIT relies on COSE for authentication, with digital signatures being the most
used method. A viable alternative for CubeSat maybe to instead use a tagged Message
Authentication Code (MAC). This will reduce the size of \textit{Authentication} block
\ref*{tab:manifest-overhead} from 64Bytes to 16Bytes or 8Bytes if using HAMC-256/128
or HMAC-256/64. This would also save Flash since as seen in~\cite{zandberg2019secure}
the ed25519 library accounts for roughly 75\% of the crypto flash budget, while HMAC-256
re-uses sha256 code, and adds an overhead of ~1Kbyte. The requirement for a shared secret
might be an acceptable compromise since attackers gaining physical access to the
in-orbit device is unlikely.

\subsubsection{SUIT Manifest Overhead}

In space communication transferring data is costly, reducing the Manifest
overhead~\ref{tab:manifest-overhead} for mission files transfers is highly
desirable. This can be done by using \texttt{COSE\_MAC0\_tagged} instead of
\texttt{COSE\_SGN0\_tagged} (-56Bytes) and integrating the payload into the
manifest (-64Bytes from the URI), reducing the manifest size to 162Bytes,
effectively reducing the overhead to \~23\%.

